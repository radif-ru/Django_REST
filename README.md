# Full Stack разработка. 
> [https://backend.radif.ru/](https://backend.radif.ru/) - `Backend` - сервер
> 
> [https://backend.radif.ru/swagger/](https://backend.radif.ru/swagger/) - `OpenAPI` `Swagger`
> 
> [https://backend.radif.ru/redoc/](https://backend.radif.ru/redoc/) - `OpenAPI` `ReDoc`
> 
> [https://backend.radif.ru/api/](https://backend.radif.ru/api/) - `Django REST API`
> 
> [https://backend.radif.ru/graphql/](https://backend.radif.ru/graphql/) - `GraphiQL` 
> 
> [https://backend.radif.ru/administration/](https://backend.radif.ru/administration/) - Админка 
> 
> [https://backend.radif.ru/api/token/](https://backend.radif.ru/api/token/) - Генерация токена 
> 
> [https://backend.radif.ru/api/token/refresh/](https://backend.radif.ru/api/token/refresh/) - Обновить токен 
> 
> [https://backend.radif.ru/swagger.json](https://backend.radif.ru/swagger.json) - `REST API` в `Json`
> 
> [https://backend.radif.ru/swagger.yaml](https://backend.radif.ru/swagger.yaml) - `REST API` в `YAML`
> 
> [https://frontend.radif.ru/](https://frontend.radif.ru/) - `Fronted` - клиент

## Django REST framework. React. JWT. OpenAPI. Swagger. ReDoc. GraphQL. AsyncIO. Aiohttp. Contextvars. Docker Compose. Gunicorn. Nginx. Linux. VPS-сервер.
### Проект «Web-сервис для работы с TODO-заметками».

> В проекте нет упора на вёрстку или стили - при желании делаю `Pixel Perfect` под любой дизайн, работаю с `препроцессорами`, `переменными`, `миксинами`, `расширениями` для стилей и т.д...

> Главное - освоение новых технологий, функциональность, производительность, обеспечение безопасности, целостности данных, оптимизация запросов к БД, взаимодействие `Backend` (серверной части) и `Frontend` (клиентской части) и т.д.

## Стек технологий

### Библиотеки на основе Python 3.10

> `django` (v. 3.2.9) - `Django framework`
> 
> `djangorestframework` (v. 3.12.4) - `Django REST framework`
> 
> `markdown` (v. 3.3.4) - Язык разметки
> 
> `django-filter` (v. 21.1) - Библиотека для фильтрации запросов + визуализация в браузерном `API`
> 
> `django-cors-Headers` (v. 3.10.0) - Настройка политики `CORS`. Работа с заголовками для доступа `React` к `Django`
> 
> `djangorestframework-camel-case` (v. 1.2.0) - Визуализация в верблюжий стиль для отображения JSON и браузерного `API`. И наоборот в змеиный стиль для питона
>
> `djangorestframework-simplejwt` (v. 5.0.0), в него входит пакет `PyJWT` (v. 2.3.0) - Библиотека `JSON Web Token`. Современное средство передачи данных для аутентификации в клиент-серверных приложениях, посредством `JSON`. Токены создаются сервером, подписываются секретным ключом и передаются клиенту, который в дальнейшем использует данный токен для подтверждения своей личности.
>
> `mixer` (v. 7.2.0), тянет за собой `Faker` (v. 9.8.2) и другие пакеты, подробнее в `requiremets.txt`. Mixer - удобная библиотека для генерации данных для тестов. Сам определяет типы полей модели и заполняет их соответствующим типом случайных данных. Так же определяет все связанные модели и создаёт соответствующие объекты со случайными данными. Можно выбирать дефолтные данные для нужных полей модели и связанных моделей. Поддерживает разные фреймворки.
>
> `requests` (v. 2.26.0) - Библиотека для удобного составления `HTTP`-запросов. Тянет за собой ещё несколько библиотек, подробнее в `requiremets.txt`.
>
> `drf-yasg` (v. 1.20.0), тянет за собой `Jinja2` (v. 3.0.3) и множество, с десяток других библиотек, запушил в `requiremets.txt`. `YASG` - `Swagger` для `Django REST Framework`. 
> Обеспечивает согласованность данных между `Frontend` и `Backend`. Инструменты для реализации `OpenAPI`. Автоматическая генерация документации `API` - которую можно, например, сразу отдать фронтендеру в виде `HTML`- страницы, в `json` формате, `yaml` и т.д.
> То есть разработчик клиентской части (без разницы - web, мобильного, десктопного и др. приложения на любом языке) может сразу начать писать согласованный с сервером код.
>
> `graphene-django` (v. 2.15.0), так же подтягиваются `promise` (v. 2.3), `graphql-core` (v. 2.3.2) и другие библиотеки для работы с альтернативой `REST` - `GraphQL` на `Django`. Используется другая архитектура, язык и механизмы создания, отправки запросов к БД и т.д.
>
> `psycopg2-binary` (v. 2.9.2) - скомпиленный wheel-пакет с бинарниками. Адаптер базы данных `PostgreSQL` для языка программирования `Python`. Его основными функциями является полная реализация спецификации `Python DB API 2.0` и безопасность потоков. Предназначен для сильно многопоточных приложений
> 
> `gunicorn` (v. 20.1.0) - `HTTP`-сервер с интерфейсом шлюза веб-сервера `Python` (`WSGI`).
> 
> `asyncio` - встроенная библиотека для асинхронного программирования
> 
> `aiohttp` (v. 3.8.1) - тянет за собой `aiosignal` (v. 1.2.0), `async-timeout` (v. 4.0.2),
> `frozenlist` (v. 1.2.0), `multidict` (v. 5.2.0), `yarl` (v. 1.7.2), `attrs` (v. 21.2.0),
> Библиотека aiohttp предоставляет асинхронный `HTTP`-клиент, построенный поверх `asyncio`. 
> Эта библиотека позволяет отправлять запросы последовательно, но 
> не дожидаясь первого ответа, прежде чем отправлять новый.
> 
> `contextvars` - встроенный модуль - предоставляет `API`-интерфейсы для управления, 
> хранения и доступа к локальному контексту состояния.

#### Внутри docker-compose используются образы для контейнеров из докер хаба:

> `python:3.10-slim`
>
> `Postgres:14.1-alpine ` - Система, комплекс приложений и утилит для работы `PostgreSQL` - свободная объектно-реляционная система управления базами данных (`СУБД`).
> 
> `nginx:1.21.4-alpine` - Система, комплекс приложений и утилит для работы `Nginx` - веб-сервер и почтовый прокси-сервер, работающий на `Unix`-подобных операционных системах.

### Библиотеки на основе JavaScript, Node.js и др.

> `npx` - Режим одноразового запуска, пакет для запуска пакетов без установки в систему.
> 
> `create-react-app` Создание/установка проекта на `React` (v. 17.0.2) + `Babel`, `Webpack` и другие полезные зависимости для комфортной работы.
> 
> `axios` (v. 0.24.0)  - Библиотека для браузеров и Node.js, HTTP-клиент.
> 
> `react-router-dom` (v. 6.0.2) - Маршрутизация `<BrowserRouter>`, `<HashRouter>` и другие компоненты.
> 
> `dateformat` (v. 5.0.2) - Преобразование даты.
> 
> `universal-cookie` (v. 4.0.4) - Универсальные `Cookies` для `React` и не только. Удобство использования.
>
> `bootstrap` (v. 5.1.3) - Библиотека `Bootstrap 5` - `HTML`, `CSS`-шаблоны, `JavaScript`-расширения. Содержит `@popperjs/core` (v. 2.10.2) - зависимость, механизм подсказок и всплывающих окон, подгружается через `node_modules/bootstrap/dist/js/bootstrap.bundle.min.js`. Так же содержит другие зависимости, которые отображены в корне `bootstrap`, файле `package.json`.
>
> `SASS` - Метаязык на основе CSS, предназначенный для увеличения уровня абстракции CSS-кода и упрощения файлов каскадных таблиц стилей. Используются фишки препроцессора: переменные, расширения, примеси, функции для стилей и т.д.

## Frontend. SPA. Точка входа https://frontend.radif.ru

> У авторизованных пользователей появляются новые возможности. Личный кабинет. Можно создавать и удалять свои проекты, заметки, редактировать данные и т.д. 
> 
> У администраторов полный доступ - можно удалять (кроме пользователей) и редактировать любые данные.

> https://frontend.radif.ru - `Single Page Application` - Вход в приложение, подгрузка данных из `backend`-а, дальше перемещение по всем компонентам с помощью меню, без перезагрузки страницы.
> Если пользователь не авторизован для получения данных используется - `GraphQL`. Если авторизован - `Django REST`.
>
> https://frontend.radif.ru/users/ - Подгрузка компонента `Пользователи`, данные всех пользователей в табличном виде с возможностью перехода на конкретного пользователя, отображение дней рождения переформатировано
>
> https://frontend.radif.ru/users/3/ - Все данные пользователя (кроме системных и пароля) по `id` `<3>` из БД на `backend`-е.
> Так же подгружаются все проекты и заметки пользователя ко всем проектам. 
> У авторизованных есть возможность изменять все свои данные указанные при регистрации. Попасть на эту страницу так же можно по кнопке `ЛК | <login>` (видна только авторизованным) в меню сверху.
> Появляются кнопки для добавления, изменения, удаления данных - при нажатии генерируются формы редактирования.
> Администратор может зайти к любому пользователю и изменить его данные или удалить его проекты и заметки.
> 
> https://frontend.radif.ru/projects/ - Подгрузка компонента `Проекты`, данные всех проектов в табличном виде, возможность перехода к конкретному проекту или к пользователям работающими с конкретным проектом. 
> Для авторизованных: возможность удалять свои проекты - появляется кнопка `Del` - рядом со своими проектами, у администратора - кнопка `Del` - рядом со всеми проектами.
> 
> https://frontend.radif.ru/projects/3/ - Данные Проекта по `id` `<3>` из БД на `backend`-е. + Отображаются имена/ссылки всех пользователей, кто работают с проектом. + Отображаются все заметки оставленные к проекту с данными чья это заметка и переформатированными датами создания/обновления. Данные собираются и фильтруются из разных источников, собранных в `SPA`, но без повторных запросов к БД!
> Если этот проект принадлежит авторизованному пользователю он может его редактировать, а так же свои заметки, появляются кнопки для добавления, изменения, удаления данных. 
> К проекту так же можно добавить (из сформированного списка) других зарегистрированных пользователей работающих с этим проектом.
> Заметки можно оставлять к любым проектам. При создании проекта пользователю назначается роль - `владелец проекта`.
> Администратор может зайти в любой проект и изменить или удалить его, а так же оставленные к нему заметки.
> 
> https://frontend.radif.ru/todos/ - Подгрузка компонента `Заметки`, данные всех заметок в табличном виде, возможность перехода к проекту, к которому оставлены конкретные заметки.
> Для авторизованных: возможность удалять свои заметки - появляется кнопка `Del` - рядом со своими заметками, у администратора - кнопка `Del` - рядом со всеми заметками.
>
> https://frontend.radif.ru/login/ - Компонент с формой, где происходит авторизация на стороне клиента. От сервера в ответ приходит токен `JWT` и сохраняется в `Cookies`, соответственно даже после перезагрузки приложения или браузера пользователь остаётся авторизованные пока не разлогинится или не истечёт срок действия токена. При любых последующих запросах токен, взятый из `Cookies`, прикладывается с префиксом `Bear_R@d1f` для `JWT` и другими данными к заголовкам. Пока пользователь залогинин в меню отображается логин пользователя с кнопкой `Выйти` - то есть деавторизации
> 
> Нажатие кнопки `Выйти` (видна авторизованным) - деавторизация на стороне клиента. Происходит разлогинивание, из `Cookies` удаляется токен и логин
>
> Кнопка `ЛК | <login>` - личный кабинет, описана выше, как и поведение остальных кнопок.
> 
> https://frontend.radif.ru/registration/ - Регистрация пользователя. Во время регистрации новому пользователю автоматически назначается роль - `разработчик`. Доступна только неавторизованным пользователям. На сервере настроено ограничение на возможность регистрации - только администраторы могут создавать другие аккаунты в авторизованном состоянии!

## Backend. Точка входа https://backend.radif.ru Web-ресурсы

> https://backend.radif.ru/administration/ - Админка

> https://backend.radif.ru/swagger/ - `OpenAPI` - Универсальный интерфейс для пользователей (клиентов) по взаимодействию с сервисами (серверами). Не зависит от языков программирования. Подробнее ниже, в методах `API`.
>
> https://backend.radif.ru/redoc/ - `OpenAPI` - Другое использование и отображение созданной спецификации. Подробнее ниже, в методах `API`.

> https://backend.radif.ru/graphql/ - `GraphiQL` - Хороший отладочный инструмент. Доступность включена только в режиме `DEBUG`, позволяет проводить, тестировать запросы на языке `GraphQL` прямо в браузере в удобном интерфейсе с подсказками, историей, моими описаниями моделей и их полей и т.д.

## Backend. Точка входа https://backend.radif.ru Методы API проекта, Endpoint-ы

### `GraphQL` - альтернативный вариант построения `API`:
> Тут `GraphQL` используется в клиенте на `React` только для примера, для получения данных неавторизованным пользователем, после авторизация и все последующие запросы проходят через `endpoint`-ы `Django REST` с присоединением токена `JWT` в заголовках.

> https://backend.radif.ru/graphql/ - все запросы к `API GraphQL` проходят через этот единый `Endpoint`. 
>
> Как выглядят запросы со стороны клиента
> 
> 1. `GET`. Через параметры адреса. Запрос на языке `GraphQL` должен быть помещён в виде строки в параметр `query`. Пример простого запроса, через параметр адреса, на вывод некоторых данных:
> 
> `/graphql/?query={allUsers {id username firstName lastName birthdate}}` - `Endpoint` с параметром `query`
>
> 2. `POST`. `JSON`. Через тело запроса. Запрос на языке `GraphQL` должен быть помещён в виде строки в тело запроса в поле объекта `JSON` - `query`. Пример простого запроса, через тело запроса, на вывод некоторых данных:
>
> `/graphql/` - `Endpoint` 
> 
> `{
>     "query": "{allUsers {id username firstName lastName birthdate}}"
> }` - Тело
> 
> Посмотреть включённые запросы, ограничения, мутации и т.д. можно в `backend/config/shema.py`

### REST - основной вариант построения API в этом проекте:
> Вся основная логика `API` бэкенда в `Django REST`.

### Документация API. OpenAPI. Swagger. ReDoc. Согласованность Frontend и Backend

> https://backend.radif.ru/swagger/ - `HTML` - формат. `Swagger`. То есть удобное, красиво и функционально оформленное отображение прямо в браузере. Встроены различные инструменты, тянет за собой мои описания полей моделей, методов, миксинов, классов в коде и др., показывает поддерживаемы типы, ограничения, можно работать с любыми запросами, получить консольные команды для запуска через `curl` и т.д.
> 
> https://backend.radif.ru/redoc/ - `HTML` - формат. `ReDoc`. Так же удобный вид браузерной визуализации сгенерированной документации `API`. Но созданная спецификация используется и отображается по другому.
> 
> https://backend.radif.ru/swagger.json - `JSON` - формат. Можно отдать для изучения разработчикам клиентской части, использовать для автоматизации в любом `Frontend`-е, на любом языке.
> 
> https://backend.radif.ru/swagger.yaml - `YAML` - формат

### Система версий API
> Включён контроль системы версий по заголовкам. 
> Необходимо внутри заголовков, в `Headers` добавить поле `Accept` и в нём указать, например: 
> `\application/json; version=2.0` - вместо 2.0 может быть любая другая версия, от этого будет зависеть какие данные придут в ответ. 
> Так же в коде закомментены другие методы по контролю версий, например в зависимости от url-адресов или имени хоста.

### Сигналы. Обработчики сигналов
> О любых действиях - изменение, создание, удаление данных рассылаются оповещения по электронным адресам их владельцев. В данном случае все письма хранятся в папке tmp. Но если подключить домен, можно настроить рассылку с реального почтового адреса на реальные почтовые ящики - уже так делал.

### Браузерная авторизация

> https://backend.radif.ru/api/auth/login/ - Авторизация пользователя
>
> https://backend.radif.ru/api/auth/logout/ - Деавторизация пользователя

### Авторизация с помощью JWT - JSON Web Token

> https://backend.radif.ru/api/token/ - Получение Токена через `POST` запрос для авторизации
> 
> https://backend.radif.ru/api/token/refresh/ - Сброс / обновление токена

### Посещения страниц
> https://backend.radif.ru/api/visits/ - `GET`, `HEAD`, `OPTIONS` - Фиксация количества посещений всех точек входа `Backend`-a, сюда же входят все запросы по `API` от клиента, последняя дата посещения. Если пользователь авторизован фиксируется его идентификатор

### Пользователи

#### Система прав: 
> 1. Администраторы (Джанговские и из моих групп зависимостей) могут всё 
> 2. Изменять данные может владелец данного аккаунта. 
> 3. Удалить аккаунт может владелец данного аккаунта. 
> 4. Создать аккаунт может любой - если не авторизован! Администратор, даже авторизованный, всегда может создавать новые аккаунты.
> 5. Читать данные могут все. Но не все данные включены в сериализаторе

> https://backend.radif.ru/api/users/ - `GET`, `POST`, `HEAD`, `OPTIONS` - Вывод данных всех пользователей. Регистрация. В сериализаторе включена фильтрация по возрасту. Если меньше 18 лет, зарегистрироваться не получится. Пароль ввести/обновить можно, но прочитать нельзя. По запросу `<`GET`>` приходят множественные данные - все связанные объекты, а так же их вложенное множество объектов. Чтобы получить данные без вложенности есть другие методы `API`, описанные ниже.
>
> https://backend.radif.ru/api/users/3/ - `GET`, `PUT`, `PATCH`, `DELETE`, `HEAD`, `OPTIONS` - В зависимости от метода запроса - вывод данных, редактирование и т.д. пользователя по `<id>` в БД, вместо `<3>` подставить id Пользователя.

#### Extra Actions:

> https://backend.radif.ru/api/users/3/login/ - `GET`, `HEAD`, `OPTIONS` - Вывод уникального логина пользователя по id в БД, вместо `<3>` подставить id Пользователя
>
> https://backend.radif.ru/api/users/3/fio/ - `GET`, `HEAD`, `OPTIONS` - Вывод фамилии, имени, отчества пользователя по id в БД, вместо `<3>` подставить id Пользователя
>
> https://backend.radif.ru/api/users/superusers/ - `GET`, `HEAD`, `OPTIONS` - Вывод данных всех суперпользователей
> 
> https://backend.radif.ru/api/users/active - `GET`, `HEAD`, `OPTIONS` - Получить всех активных пользователей без вложенных объектов
> 
> https://backend.radif.ru/api/users/inactive - `GET`, `HEAD`, `OPTIONS` - Получить всех неактивных пользователей без вложенных объектов

#### Фильтры:

> https://backend.radif.ru/api/users/?login=va - `GET`, `POST`, `HEAD`, `OPTIONS` - Вывод данных пользователей отфильтрованных по части логина (фильтрация в БД username__contains), вместо `<va>` подставляем часть (можно даже 1-2 буквы) уникального логина пользователя. Настроено вручную стандартными методами
>
> https://backend.radif.ru/api/users/?first_name=Vasya&middle_name=Niko&last_name=Pe - `GET`, `HEAD`, `OPTIONS` - Вывод данных пользователей, отфильтрованных по части имени, части фамилии, части отчества вместо `<Vasya>` подставляем часть имени, вместо `<Pe>` часть фамилии, вместо `<Niko>` часть отчества пользователей. Некоторые данные можно опускать или комбинировать, в том числе с другими методами фильтрации, как например по части логина выше. Настроено с помощью кастомного `django-filter`
>
> https://backend.radif.ru/api/users/?limit=2&offset=1 - `GET`, `POST`, `HEAD`, `OPTIONS`- В поле `<2>` указываем количество пользователей, чьи данные придут в ответе на запрос, в поле `<1>` - смещение относительно первого пользователя. В ответ кроме пользователей приходят ссылки на смещение относительно страницы и другие данные

### Проекты

#### Система прав:
> 1. Администраторы (Джанговские и из моих групп зависимостей) могут всё.
> 2. Изменять данные могут пользователи, которые работают с проектом.
> 3. Удалить проект могут пользователи, которые работают с проектом.
> 4. Создать проект может любой пользователь, если авторизован.
> 5. Читать данные могут все. Но не все данные включены в сериализаторе

> https://backend.radif.ru/api/projects/ - `GET`, `POST`, `HEAD`, `OPTIONS` - Список проектов, создание проекта. По запросу `GET` приходят множественные данные - все связанные объекты, а так же их вложенное множество объектов. Чтобы получить данные без вложенности есть другие методы `API`, описанные ниже.
>
> https://backend.radif.ru/api/projects/3/ - `GET`, `PUT`, `PATCH`, `DELETE`, `HEAD`, `OPTIONS` - Вывод, редактирование, удаление проекта, вместо `3` подставить id Проекта

#### Extra Actions:

> https://backend.radif.ru/api/projects/active - `GET`, `HEAD`, `OPTIONS` - Получить все активные проекты без вложенных объектов
> 
> https://backend.radif.ru/api/projects/inactive - `GET`, `HEAD`, `OPTIONS` - Получить все неактивные проекты без вложенных объектов

#### Фильтры:

> https://backend.radif.ru/api/projects/?name=лики - `GET`, `POST`, `HEAD`, `OPTIONS` - Вывод данных проектов, отфильтрованных по части имени, вместо `<лики>` подставляем часть имени проектов. Настроено с помощью кастомного `django-filter`
>
> https://backend.radif.ru/api/projects/?limit=2&offset=1/ - `GET`, `POST`, `HEAD`, `OPTIONS` - В поле `<2>` указываем количество проектов, данные которых придут в ответе на запрос, в поле `<1>` - смещение относительно первого проекта. В ответ кроме проектов приходят ссылки на смещение относительно страницы и другие данные

### Заметки

#### Система прав:
> 1. Администраторы (Джанговские и из моих групп зависимостей) могут всё.
> 2. Изменять данные может создатель заметки.
> 3. Удалить заметку может её создатель.
> 4. Создать заметку может любой пользователь, если авторизован.
> 5. Читать данные могут все. Но не все данные включены в сериализаторе

> https://backend.radif.ru/api/todos/ - `GET`, `POST`, `HEAD`, `OPTIONS` - Список заметок, создание заметки. По запросу `GET` приходят множественные данные - все связанные объекты, а так же их вложенное множество объектов. Чтобы получить данные без вложенности есть другие методы `API`, описанные ниже.
>
> https://backend.radif.ru/api/todos/3/ - `GET`, `PUT`, `PATCH`, `DELETE`, `HEAD`, `OPTIONS` - Вывод, редактирование, удаление заметки (Метод переопределён! Вместо фактического удаления активность меняется на 0 (`False`)), вместо `3` подставить id Заметки

#### Extra Actions:

> https://backend.radif.ru/api/todos/async_fish_todos - `GET`, `HEAD`, `OPTIONS` - Получить сгенерированные Рыба-тексты, асинхронно загруженные с помощью `asyncio` и `aiohttp`, через `API` https://fish-text.ru/api
> 
> https://backend.radif.ru/api/todos/active - `GET`, `HEAD`, `OPTIONS` - Получить все активные заметки без вложенных объектов
> 
> https://backend.radif.ru/api/todos/inactive - `GET`, `HEAD`, `OPTIONS` - Получить все неактивные заметки без вложенных объектов

#### Фильтры:

> https://backend.radif.ru/api/todos/?created_after=1995-2-25&created_before=2021-12-10&project=3&project__name=Сложившаяся%20структура - `GET`, `POST`, `HEAD`, `OPTIONS` - Вывод данных заметок. Фильтрация заметок по дате, в поле `<1995-2-25>` - указываем от какой даты считаем, в поле `<2021-12-10>` - до какой даты. Фильтрация заметок по id, поле `<3>`, в браузере можно сразу выбрать проект. Фильтрация заметок по имени проекта, поле `<Сложившаяся%20структура>`. Достаточно использовать 1 из фильтров или использовать комбинации. Настроено с помощью кастомного `django-filter`, некоторые поля дефолтные
>
> https://backend.radif.ru/api/todos/?limit=3&offset=2/ - `GET`, `POST`, `HEAD`, `OPTIONS` - В поле `<3>` Указываем количество заметок, данные которых придут в ответе на запрос, в поле `<2>` - смещение относительно первой заметки. В ответ кроме заметок приходят ссылки на смещение относительно страницы и другие данные

### Роли. Система прав

> https://backend.radif.ru/api/roles/ - `GET`, `HEAD`, `OPTIONS` - Список ролей. По запросу `GET` приходят множественные данные - все связанные объекты, а так же их вложенное множество объектов. Чтобы получить данные без вложенности есть другие методы `API`, описанные ниже.

#### Extra Actions:

> https://backend.radif.ru/api/roles/only - `GET`, `HEAD`, `OPTIONS` - Получить все роли без вложенных объектов

## Консольные команды в рамках проекта для запуска моих скриптов:

> `python manage.py add_all_data` - Скрипт единой точки создания всех дефолтных данных в БД. Данные собираются рандомно
>
> `python manage.py add_roles` - Скрипт заполнения таблиц БД дефолтными группами прав, ролями
>
> `python manage.py add_users` - Скрипт заполнения таблиц БД дефолтным админом и пользователями. Так же админ добавляется в группу разрешений Администратор, остальные дефолтные пользователи попадают в рандомные группы разрешений из БД (но не в группу Администраторов!). В группу Владелец проекта будут так же попадать те, кто будут создавать свои проекты. В группу Разработчик будут попадать те, кто оставляют заметки. Администраторов смогут назначать только администраторы.
>
> `python manage.py add_projects` - Скрипт заполнения таблиц БД дефолтным проектами, те в свою очередь связываются с рандомными дефолтными пользователями из БД, работающими с конкретными проектами
>
> `python manage.py add_todos` - Скрипт заполнения таблиц БД дефолтным заметками, каждая привязывается к конкретным рандомному проекту и конкретным рандомному пользователю из БД

## Тесты
> `python manage.py test` - для запуска всех тестов приложений `backend`-a.

> Если нужно и есть на это время, могу глубже вникнуть и стандартизированно покрывать тестами весь код.

> Обычно и так всё тестирую самостоятельно через `Postman`, `отладчик`, `дебагер PyCharm` в ходе
> разработки - даже без документации, просто вникаю, что происходит внутри,
> захожу в исходники и разбираюсь, прогоняя разные варианты и устраняя ошибки.

> Для `JavaScript`, `React` использую `браузерный дебагер`, `отладчик` - можно работать с кодом, стилями, заголовками, сетью, отслеживать нагрузку - время, размер, содержимое прогоняемых данных в обе стороны,
> `React Developer Tools`, делать проверку на `Pixel Perfect`, ставить точки остановки для скриптов, отслеживать данные переменных, с хранилищами типа
> `Cookies`, `Local Storage` и многое другое - большинство инструментов уже встроено.


# Полезные команды:

### Консольные команды Backend-а (Python, Django, DRF)

> `python venv env` - Создание виртуального окружения

> `pip install django djangorestframework markdown django-filter` - Установка зависимостей, полезных библиотек

> `pip freeze > requirements.txt` - Помещаем все зависимости проекта в файл `requirements.txt`

> `pip install -r requirements.txt` - Устанавливаем все зависимости проекта из файла `requirements.txt`

> `pip list` - Удобное отображение всех установленных приложений, библиотек

> `django-admin startproject config` - Создание проекта 'config'

> `python manage.py startapp users` - Создание приложения 'Пользователи'

> `python manage.py makemigrations` - Создание миграций, необходимо после создания/обновления моделей

> `python manage.py migrate` - Выполнение миграций

> `python manage.py sqlmigrate <app_name>` - Выполняется после создания миграций. Позволяет вывести на экран SQL-запросы, которые будут генерироваться для Django командой применения миграций к базе данных (то есть к таблицам, соответствующим указанному приложению)

> `python manage.py collectstatic` - Сборка стандартных и подготовленных статических файлов

> `python manage.py createsuperuser` - Создание супер-пользователя

> `python manage.py runserver 0.0.0.0:3333` - Запуск проекта на порту 3333 (доступ http://localhost:3333)

> `python manage.py test` - Запуск всех созданных тестов для приложений

#### Работа с дампами БД. В проекте не использую, так как не поддерживается кириллица. Использую export БД в json файл от IDE Pycharm, дампы в каталоге dumps_pycharm_export

> `python manage.py dumpdata --indent 2 --exclude auth.permission --exclude contenttypes > ./json/dumps_django_dumpdata/all_data.json` - Дамп всей БД, за исключением некоторых таблиц `--exclude auth.permission` и `--exclude contenttypes`, мешающих восстановлению БД из дампа. `--indent 2` - количество отступов в json файле
> 
> `python manage.py dumpdata users > ./json/dumps_django_dumpdata/users_data.json` - Дамп БД приложения `users`
> 
> `python manage.py dumpdata todo.project > ./json/dumps_django_dumpdata/todo_project_data.json` - Дамп БД конкретной таблицы модели `project` приложения `todo`
> 
> `python manage.py dumpdata todo.todo > ./json/dumps_django_dumpdata/todo_todo_data.json` - Дамп БД конкретной таблицы модели `todo` приложения `todo`
> 
> `python manage.py loaddata ./json/dumps_django_dumpdata/all_data.json` - импорт данных из дампа

### Консольные команды Frontend-а (JavaScript, NodeJS, npx, React)

> `npx create-react-app frontend` - Создание/установка проекта на React + Babel, webpack и другие полезные зависимости для комфортной работы, `npx` - режим одноразового запуска, пакет для запуска пакетов без установки в систему.

> `npm run start` - Запуск фронтенд проекта на отладочном сервере, выполнять в корне фронта (в данном случае в каталоге frontend)

> `npx react-codemod rename-unsafe-lifecycles` - Переименовать все устаревшие жизненные циклы на их новые имена

> `npm run build` - Сборка проекта для продакшн

### Консольные команды для систем Linux и других ОС:

> `passwd` - Изменить пароль.
> 
> `adduser radif` - Создать пользователя, заполнение данных о пользователе.
> 
> `usermod -aG sudo radif` - Добавить в группу `sudo`, чтобы дать права `root` пользователю.
> 
> `su - radif` - Переключиться на нового пользователя.
> 
> `sudo apt update` - Обновляет индексы пакетов системы. Рекомендуется выполнить перед установкой новых программных пакетов. Используется для синхронизации списков пакетов в системе. Извлекает последние списки пакетов PPA и репозиториев в системе и обеспечивает их актуальность. 
>
> `sudo apt list --upgradable` - Список пакетов, готовых к обновлению.
> 
> `sudo apt upgrade` - Обновляет пакеты до последних версий и устанавливает новые пакеты, если они требуются в качестве зависимостей. Также устанавливает все обновления безопасности, необходимые системе. Он не удаляет никакие пакеты, а если какие-либо из них предназначены для удаления, он их пропускает.
> 
> `curl <address>` - FTP-клиент / HTTP-клиент - В поле `<address>` указываем необходимый ресурс и получаем данные как например `JSON` по `API`, так и целого сайта и т.д.
>
> `python -m pip install --upgrade --force-reinstall pip` - Помогает, если возникают ошибки, при смене каталога виртуального окружения.
>

#### Очищаю систему, освобождаю место на сервере
> 
> `df -h` - Узнать свободное место
> 
> 1. `sudo apt remove python2 --simulate` - Симуляция удаления (н-р `python2`), показ что случится после этого
> 2. `sudo apt remove python2` - удаления (н-р `python2` - лучше этого не делать!)
> 3. `sudo apt autoremove --purge` - удаления файлов конфигурации и неиспользуемых пакетов
>
> `dpkg -l | grep python` - `dpkg -l` Посмотреть все установленные пакеты `| grep python` отфильтрованных по слову python
> 
> 1. `ls /boot/` - Посмотреть ядра системы 
> 2. `sudo uname -a` - Текуще используемое ядро
> 3. `apt list --installed | egrep "linux-image|linux-Headers"` - Какие версии ядер были установлены
> 4. `dpkg --list | egrep "linux-image|linux-Headers"` - Список ядер
> 5. `sudo apt purge linux-image-unsigned-5.4.0-88-generic linux-image-unsigned-5.4.0-74-generic` - Выбираю и удаляю лишние
> 6. `sudo update-grub2` - После нужно обновить конфигурацию `Grub` 
> 7. `sudo apt --purge autoremove` - Скрипт `purge-old-kernels`, который можно было использовать для удаления старых ядер
> 8. `sudo apt-`GET` purge $(dpkg -l 'linux-*' | sed '/^ii/!d;/'"$(uname -r | sed "s/\(.*\)-\([^0-9]\+\)/\1/")"'/d;s/^[^ ]* [^ ]* \([^ ]*\).*/\1/;/[0-9]/!d' | `HEAD` -n -1)` - Удалить все старые ядра, кроме используемого и предпоследнего
> 9. `sudo apt autoremove` - Затем нужно выполнить команду очистки системы 
> 10. `sudo update-grub` - и вручную обновить конфигурацию `grub`.
> 

#### Получение сертификатов

> `sudo certbot certonly --dry-run --standalone -d frontend.radif.ru -d backend.radif.ru -d django.radif.ru -d intergalactic.radif.ru -d radif.ru` - Проверка возможности получения, возможные ошибки. Делается так как существует ограничение на выдачу сертификатов и лучше сначала проверить команду
> 
> `sudo certbot certonly --standalone -d frontend.radif.ru -d backend.radif.ru -d django.radif.ru -d intergalactic.radif.ru -d radif.ru` - Получение сертификатов `--standalone` - позволяет получить быстро, без доп манипуляций с конфигами `nginx`

### Консольные команды Git:

> `git remote set-url origin https://radif:radif_token@github.com/radif-ru/www.git` - Чтобы не вводить каждый раз пароль, вместо `radif_token` - подставить сгенерированный токен `git`, `www` - название репозитория
> 
> `git reset --hard <hash>` - Жесткое удаление коммита. Вместо `<hash>` - хэш-код коммита, к которому хотим вернуться
> 
> `git push --force` - Принудительно запушить изменения в `GitHub`. Например, перед этим можно выполнить действие выше и коммит удалится не только на ПК, но и на `GitHub` 
>
> `git commit --amend -m 'Новое сообщение'` - Переименование предыдущего коммита, так же как и при удалении коммита, нужно выполнить команду ниже. Не стоит так делать, если ещё кто-то пользуется этим репозиторием, иначе могут возникнуть конфликты и ошибки!
> 
> `git push --force origin <имя ветки на удаленном репозитории>` - Опасная команда, может привести к потерям - если репозиторий используется несколькими пользователями!
> 

### Консольные команды для Docker-compose: 

> `docker-compose build` или `docker-compose -f docker-compose.prod.yml build` - Создать образ. Префикс `-f` `имя_файла`, после `docker-compose` позволяет запускаться из файла с нестандартным именем для выполнения любых возможных команд

> `docker-compose up` или `docker-compose -f docker-compose.prod.yml up` - Запустить контейнер

> `docker-compose up -d --build --remove-orphans` или `docker-compose -f docker-compose.prod.yml up -d --build --remove-orphans` - Создать образ и запустить контейнер в фоне (`-d`). `--remove-orphans` - Удаление контейнеров для не определённых служб в файле создания

> `docker image ls -a && docker container ls -a && docker volume ls && docker network ls` - Посмотреть все образы/контейнеры/тома/сети

> `docker exec -it <CONTAINER ID> bash` или `docker exec -it <CONTAINER ID> sh` и т.д. - Зайти в работающий контейнер 

> `docker-compose down` или `docker-compose -f docker-compose.prod.yml down` - Остановить запущенные контейнеры и сети

> `docker-compose down -v` или `docker-compose -f docker-compose.prod.yml down -v` - Удалить тома вместе с контейнерами

> `docker system prune` или `docker container prune && docker image prune && docker volume prune && docker network prune` - Удалить неиспользуемые контейнеры/образы/тома/сети

> `docker-compose logs -f` или `docker-compose -f docker-compose.prod.yml logs -f` - Проверка наличия ошибок в журналах, просмотр логов

> `docker network create nginx-proxy` - Создать сеть `nginx-proxy`

> `docker volume inspect django-on-docker_Postgres_data` - Проверить, что том (volume) был создан

> `docker rmi <CONTAINER ID>`, `docker rmi -f <CONTAINER ID>` - Удалить образ 

> `docker image rm <name_or_id>`, `docker container rm <name_or_id>`, `docker volume rm <name_or_id>` - Удалить образы, контейнеры, тома по названию или id

> `docker stop <CONTAINER ID>` - Приостановить контейнер 

> `docker start <CONTAINER ID>` - Запустить ранее остановленный контейнер 

> `docker restart <CONTAINER ID>` - Перегрузить контейнер 

> `docker ps`, `docker ps -a` - Посмотреть работающие и все контейнеры 

> `docker images` - Посмотреть список всех образов

> `service docker restart` - Перезапустить сервис докера

#### Работа с django, manage.py (сервис web):

> `docker-compose exec web python manage.py flush --no-in`PUT` ` - Очистка таблиц

> `docker-compose exec web python manage.py makemigrations --no-in`PUT`` - Создание миграций

> `docker-compose exec web python manage.py migrate` - Запуск миграций

> `docker-compose exec web python manage.py collectstatic --no-in`PUT` --clear` - Сборка стандартных и подготовленных статических файлов 

### PostgreSQL и Docker Compose
> `docker exec -i 864763038dfb pg_restore -U radif -v -d geekshop < ./geekshop_Postgres.dump` - Восстановить БД из дампа снаружи, не входя в контейнер

#### Вход в PostgreSQL (сервис db): 
> `docker-compose exec db psql --username=admin --dbname=db_name` - Вход в сервис `db`, а внутри него вход в Postgres, имя `admin`, бд `db_name`
##### Внутри PostgreSQL: 
> ` # \l ` - Показать базы данных

> ` # \c db_name ` - Подключение к базе данных `db_name`

> ` # \dt ` - Список зависимостей

> ` # \q ` - Выход из Postgres
